#指针

Rust 指针是其众多特性中格外引人注目的一个，当然，也格外困扰 Rust 新手。即使你拥有 C++ 背景也会有不同程度的困惑。这篇手册有助你理解指针这个重要主题。

我们这有个[速查表](http://doc.rust-lang.org/book/pointers.html#cheat-sheet)可以帮助你了解指针的类型、名称、作用。

##介绍
如果你不了解指针，这儿提供一个简介。指针在系统级编程语言里是非常基础的部分，理解它很重要。

###指针基础
当你创建值绑定的时候其实是在给栈上分配的一个值命名。（如果不知道什么是栈和堆请移步 [stackoverflow](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)) 例如：

	let x = 5i;
	let y = 8i;
	
|  location | value  |
|-----------|--------|
|  0xd3e030 |  5     |
|  0xd3e028 |  8     |

这里我们标记处了值的地址，`x` 对应于内存 0xd3e030 处 的 `5`。当我们提到 `x` 时，它的值就是 `5`.

让我们引进一个指针。在一些语言里，只有一种指针，但在 Rust 里我们有好几种，这儿我们使用 Rust 的引用，这是最简单的一种指针。

	let x = 5i;
	let y = 8i;
	let z = &y;
	
	
|  location | value  |
|-----------|--------|
|  0xd3e030 |  5     |
|  0xd3e028 |  8     |
|  0xd3e020 | 0xd3e028 |

看到不同之处了吗？区别于直接保存值，指针保存的是一个内存的一个地址，在这里 z 保存的是 y 的地址。x , y 是 int 型，而 z 是 &int 型。我们可以用 `{:p}` 打印地址：

	println!("{:p}",z);
	
这会打印 0xd3e028.

因为 int 和 &int 是不同的类型，我们不能将它们相加：

	println!("{}", x + z)
	
这会报错：

	hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int 	but found &-ptr)
	hello.rs:6     println!("{}", x + z);
                                  ^
我们可以用 `*	` 符号解引用指针。解引用就是获取指针保存的地址指向的值，

	let x = 5i;
	let y = 8i;
	let z = &y;
	
	print!("{}", x + *z);
	
打印出 13.

好了，总结一下，指针就是指向某个内存地址。我们讨论完了什么是指针，接下来看一下为什么会有指针。



##指针的使用

Rust 的指针非常有用，但用法上有别于其他语言。在讨论 Rust 指针的最佳实践之前我们来看看其他语言对指针的使用：

在 C 语言中字符串其实一个指向以 null 字符结尾的char数组的指针，使用字符串类型的唯一方式就是熟悉指针。

指针主要的作用就是指向非栈上的内存地址。前面的例子中使用两个栈上的变量，我们可以直接绑定名称。当我们在堆上分配内存的时候，我们就不能直接给它绑定名字了。在 c 里面使用 malloc 分配堆上内存，它返回一个指针。

综合前面讲的两点，每当你需要能动态改变大小的数据结构的时候就需要引入指针。编译器无法在编译的时候就分配堆上内存，所以我们编译的时候要用指针来指代它（将会在程序运行时候分配），在运行时也用这个指针来做一些操作。

##常见指针问题

我们已经讨论完指针并且指出了它的优点，那指针有哪些弊端呢？我们来看一下 Rust 一定程度上解决的指针问题：

未初始化的指针导致的问题，例如下面程序执行会发生什么就不好说了：

	%int x;
	*x = 5;
我们声明了一个指针，但没有指向任何位置，然后设置它指向位置的值为 5 。没有人知道这个没有指定的位置在哪，可能无关紧要也可能导致灾难性的后果。

当你结合函数使用指针的时候，非常容易让指针指向的内存变得无效，比如：

	func make_pointer(): &int {
		x = 5;
		return &x;
	}
	func main() {
		&int j = make_pointer();
		*j = 5; // 错误！
	}

x 是 make_pointer 函数的局部变量，在函数返回后立即失效（被释放）。但我们返回了一个指向它的指针，并且试图在 main 函数里使用这个指针，这种情况和使用未初始化的指针类似。后果不可预料。

最后一个问题，当多个指针指向同一个内存的时候会有问题。譬如：

	func mutate(&int i, int j) {
    	*i = j;
	}

	func main() {
  		x = 5;
  		y = &x;
  		z = &x; //y and z are aliased

  		run_in_new_thread(mutate, y, 1);
  		run_in_new_thread(mutate, z, 100);

  		// what is the value of x here?
	}
	

##速查表

这儿有个所有 Rust 指针类型的概述

|类型		|名称				|概述 									|
|-----------|-------------------|---------------------------------------|
|`&T`		|引用				|允许一个或者多个对象读 T 					|
|`&mut T`	|可变引用				|允许一个对象读写 T 						|
|`Box<T>`	|Box				|只允许一个持有者读写堆上分配的 T.			|
|`Rc<T>`	|引用计数指针			|可供多个对象读堆上分配的 T 					|
|`Arc<T>`	|线程安全的引用计数指针	|同上但是线程安全							|
|`*const T`	|裸指针				|读 T 是危险的							|
|`*mut T`	|可变裸指针			|读写 T 是危险的							|
