这篇将讲述 Rust 的责任（ownership）系统。这是 Rust 最为特殊和引人入胜的部分，也是 Rust 程序员必须要掌握的。Rust 是通过*责任*来实现内存安全的。责任系统分为几个部分：*责任*, *借贷* 和 *生命周期*。我们会依次介绍。

##Meta

在开始讨论之前我们先指出责任系统两点需要注意的地方。

Rust 的最大卖点就是兼顾安全和速度，并且这两项是通过零代价的抽象来实现的。责任系统是零代价抽象的主要例子。我们即将开始的所有讨论都是在编译时完成的，并没有任何运行时开销。

然而这个系统确实有一点代价：学习曲线陡峭。很多初学者都有一种和编译器 borrown checker 作斗争的感觉，自己觉得明明能编译通过的程序却报错。这是由我们理解的责任系统工作方式和实际的 Rust 实现有所不同引起了。有经验的 Rust 程序员指出随着用的越来越多，类似的问题也越来越少。

记住这些我们就开始学习责任系统。

##Ownership

责任就是说，你需要对从系统中申请的任何资源负责。资源有好多种（文件句柄等），方便起见这里我们只讨论最常用的一种资源：内存。

使用任何不提供垃圾回收的语言，只要你从堆上申请了内存就要负担起以销毁它的责任。比如一个 foo 函数分配了 4 字节的内存，然后一直没有销毁。这就会引起内存泄露，每次我们调用 foo 都会分配 4 字节。一定次数的调用之后，程序就会吃光我们的内存。这很糟糕，所以我们要以某种方式回收这 4 字节内存，另外我们也不能多回收。多次回收也会导致问题，这里先不说为什么。总之任何时候我们申请了内存，我们要确保回收那片内存并且只回收一次。多一次不行，少一次也不行。分配的次数和回收的次数要对应。

关于内存分配有个重要的细节。任何时候我们申请一块内存返回的都是指向这块内存的指针。我们通过这个指针对内存进行操作。只要指针在，我们就可以操作内存，一旦指针被销毁我们也失去了对内存操作的能力。

历来，系统编程语言都需要你手动追踪内存分配和释放。我们看一个 C 语言的例子：

	{
		int *x = malloc(sizeof(int)); // 申请内存
		*x = 5;
		free(x);	// 释放内存
	}

Rust 将资源的申请和释放设计成了一个整体，就是责任系统。

我们先来看一种简单的情况。

每当我们申请内存，我们会得到一个“责任句柄“.离开当前作用域后，你就不能使用它进行任何操作，然后Rust负责帮你释放内存。上面的例子用 Rust 表示：

	{
		let x = Box::new(5);
	}
	
这里用 Box::new 在堆上分配了能放下一个 i32 的内存。我们前面说了，申请的内存必须释放，但是我们并没有看到有关释放内存的操作，实际上 Rust 自动帮你释放了。它知道 x 是 box 的一个引用，并且知道在代码块结束时 x 会离开当前作用域，于是 Rust 编译器会在代码块最后插入释放内存的代码。这些操作都是编译器替我们完成的，不用担心会忘记，也不用担心分配和释放的次数不匹配。

这比较简单，但是如果我们要把我们的 box 传给另一个函数呢？你们也许会这样写：

	fn main() {
    	let x = Box::new(5);
    	add_one(x);
	}

	fn add_one(mut num: Box<i32>) {
    	*num += 1;
	}
	
这段代码能运行，但并不理想。假设我们要加一行代码，打印出 x 的值：

	fn main() {
    	let x = Box::new(5);
    	add_one(x);
    	println!("{}", x);
	}

	fn add_one(mut num: Box<i32>) {
    	*num += 1;
	}
	
尝试编译的话，会得到一个错误：
	
	error: use of moved value: `x`
   		println!("{}", x);
                  ^
                  
每个内存申请都要对应一个内存释放。当我们把 box 传交给 add_one 时，将会有两个指针指向同一块内存：main 函数中的 x 和 add_one 函数中的 num。如果我们还是向前面说的，在指针离开作用域就释放内存，那么这块内存将会被释放两次，这会导致程序出错。因此 Rust 规定一个资源只能有一个拥有者，所以当我们调用 add_one 的时候 Rust 会解除 x 和 box 的拥有关系，然后将 num 设为拥有者，x 不再拥有 box 资源，于是有了那个错误：use of moved value: `x`。

一种解决这个错误的方式是让 num 在用完资源后再把资源转交，怎么转交呢？返回一个 box 就行了：

	fn main() {
    	let x = Box::new(5);
    	let y = add_one(x);
    	println!("{}", y);
	}

	fn add_one(mut num: Box<i32>) -> Box<i32> {
    	*num += 1;
    	num
	}

这样就可以正常运行了。我们返回了一个 box ，资源转交给了 y 。仔细想一下， add_one 只是临时地用一下 box 而已，没必要完全将 box 转交给他。Rust 为此引入了一个*借贷*的概念，专指将资源临时转借给别人但我还是拥有者的情况。Rust 里面的引用 '&' 可以用来表示借贷。

#借贷

再来看一下当前版本的 add_one 函数：

	fn add_one(mut num: Box<i32>) -> Box<i32> {
    	*num += 1;
    	num
	}
	
这个函数传入的是 box （堆上分配的资源），一个资源不能同时有两个拥有者，所以 box 被转交给了 num。最后函数返回一个 box 又将资源转交出去了。（转交给你就是你的了，英国将香港转交给中国，香港就是中国的了，当然香港本来就是中国的）

生活中，我们常把东西借给别人用一段时间。这东西还是我的，我只是借给人家用而已。东西在谁那，谁就有责任保管好，所以东西借给他，保管责任也转移到他那边。

Rust 的责任系统于此类似，允许拥有者将资源临时的借给别人。下面是一个借贷版本的 add_one，你可以和转交版本的对比一下：

	fn add_one(num: &mut i32) {
    	*num += 1;
	}
	
这个版本从调用者那边借贷来一个 i32 ，然后递增一次。函数结束，num 被释放，借贷关系终结。

相应我们也要改一下 main 函数：

	fn main() {
    	let mut x = 5;
    	add_one(&mut x);
    	println!("{}", x);
	}

	fn add_one(num: &mut i32) {
    	*num += 1;
	}
	
这里我们只是临时借贷 box ，并不需要像之前通过返回 box 转交来转交去了那么麻烦了。

#生命周期


