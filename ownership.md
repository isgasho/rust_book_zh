这篇将讲述 Rust 的责任（ownership）系统。这是 Rust 最为特殊和引人入胜的部分，也是 Rust 程序员必须要掌握的。Rust 是通过*责任*来实现内存安全的。责任系统分为几个部分：*责任*, *借贷* 和 *生命周期*。我们会依次介绍。

##Meta

在开始讨论之前我们先指出责任系统两点需要注意的地方。

Rust 的最大卖点就是兼顾安全和速度，并且这两项是通过零代价的抽象来实现的。责任系统是零代价抽象的主要例子。我们即将开始的所有讨论都是在编译时完成的，并没有任何运行时开销。

然而这个系统确实有一点代价：学习曲线陡峭。很多初学者都有一种和编译器 borrown checker 作斗争的感觉，自己觉得明明能编译通过的程序却报错。这是由我们理解的责任系统工作方式和实际的 Rust 实现有所不同引起了。有经验的 Rust 程序员指出随着用的越来越多，类似的问题也越来越少。

记住这些我们就开始学习责任系统。

##Ownership

责任就是说，你需要对从系统中申请的任何资源负责。资源有好多种（文件句柄等），方便起见这里我们只讨论最常用的一种资源：内存。

使用任何不提供垃圾回收的语言，只要你从堆上申请了内存就要负担起以销毁它的责任。比如一个 foo 函数分配了 4 字节的内存，然后一直没有销毁。这就会引起内存泄露，每次我们调用 foo 都会分配 4 字节。一定次数的调用之后，程序就会吃光我们的内存。这很糟糕，所以我们要以某种方式回收这 4 字节内存，另外我们也不能多回收。多次回收也会导致问题，这里先不说为什么。总之任何时候我们申请了内存，我们要确保回收那片内存并且只回收一次。多一次不行，少一次也不行。分配的次数和回收的次数要对应。

关于内存分配有个重要的细节。任何时候我们申请一块内存返回的都是指向这块内存的指针。我们通过这个指针对内存进行操作。只要指针在，我们就可以操作内存，一旦指针被销毁我们也失去了对内存操作的能力。

历来，系统编程语言都需要你手动追踪内存分配和释放。我们看一个 C 语言的例子：

	{
		int *x = malloc(sizeof(int));
		*x = 5;
		free(x);
	}
	
这里调用 malloc 分配内存，free 释放内存。

Rust 将分配资源的两步合二为一，叫做 ownership，每当我们申请内存，我们会得到一个“正在使用句柄“.离开当前作用域后，你就不能使用它进行任何操作，然后系统自动帮你释放内存。

上面的例子用 Rust 写作：

	{
		let x = Box::new(5);
	}
	
这里用 Box::new 在堆上分配了能放下一个 i32 的内存。我们前面说了，申请的内存必须释放，但是在哪儿这块内存被释放了呢？Rust 自动帮你释放了。它知道 x 是 box 的一个引用，并且知道在代码块结束时 x 会离开当前作用域，于是 Rust 会在代码块最后插入释放内存的调用代码。这些操作都是编译器替我们完成的，不用担心会忘记，也不用担心分配和释放的次数不匹配。

这比较简单，但是如果我们要把我们的 box 传给另一个函数呢？例如：

	fn main() {
    	let x = Box::new(5);

    	add_one(x);
	}

	fn add_one(mut num: Box<i32>) {
    	*num += 1;
	}