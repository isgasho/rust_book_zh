这篇将讲述 Rust 的 ownership 系统。这是 Rust 最为特殊和引人入胜的部分，也是 Rust 程序员必须要掌握的。Rust 是通过 ownership 来实现内存安全的。ownership 系统分为几个部分：ownership, borrowing 和 lifetimes。我们会依次介绍。

##Meta

Rust 注重安全和速度，并且通过没有代价的抽象来实现。ownership 系统是零代价抽象的主要例子。我们即将开始的所有分析都是在编译时完成的。

然而这个系统确实有一点代价：学习曲线陡峭。很多初学者都有一种和编译器 borrown checker 作斗争的感觉，自己觉得明明能编译通过的程序却报错。这是由我们理解的 ownership工作方式和实际的 Rust 实现有所不同引起了。有经验的 Rust 程序员指出随着用的越来越多，类似的问题也越来越少。

记住这些我们就开始学习 ownership。

##Ownership

ownership 的核心就是*资源*.这里我们讨论最常用的一种资源：内存。资源还包括文件句柄等，我们主要关注内存。

当你分配了一些内存总要以某种方式销毁它。比如一个 foo 函数分配了 4 字节的内存，然后一直没有销毁。这就会引起内存泄露，每次我们调用 foo 都会分配 4 字节。一定次数的调用之后，程序就会吃光我们的内存。这很糟糕，所以我们要以某种方式回收这 4 字节内存，另外我们也不能多回收。多次回收也会导致问题，这里先不说为什么。总之任何时候我们分配了内存，我们要确保回收那片内存并且只回收一次。多一次不行，少一次也不行。分配的次数和回收的次数要对应。

关于内存分配有个重要的细节。任何时候我们申请一块内存返回的都是指向这块内存的指针。我们通过这个指针对内存进行操作。只要指针在，我们就可以操作内存，一旦指针被销毁我们也失去了对内存操作的能力。

有史以来，系统编程语言需要你手动追踪内存分配和释放。我们看一个 C 语言的例子：

	{
		int *x = malloc(sizeof(int));
		*x = 5;
		free(x);
	}
	
这里调用 malloc 分配内存，free 释放内存。

Rust 将分配资源的两步合二为一，叫做 ownership，每当我们申请内存，我们会得到一个“正在使用句柄“.离开当前作用域后，你就不能使用它进行任何操作，然后系统自动帮你释放内存。

上面的例子用 Rust 写作：

	{
		let x = Box::new(5);
	}
	
这里用 Box::new 在堆上分配了能放下一个 i32 的内存。我们前面说了，申请的内存必须释放，但是在哪儿这块内存被释放了呢？Rust 自动帮你释放了。它知道 x 是 box 的一个引用，并且知道在代码块结束时 x 会离开当前作用域，于是 Rust 会在代码块最后插入释放内存的调用代码。这些操作都是编译器替我们完成的，不用担心会忘记，也不用担心分配和释放的次数不匹配。

这比较简单，但是如果我们要把我们的 box 传给另一个函数呢？例如：

	fn main() {
    	let x = Box::new(5);

    	add_one(x);
	}

	fn add_one(mut num: Box<i32>) {
    	*num += 1;
	}