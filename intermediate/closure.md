#闭包

我们写了很多函数，他们都有一个名字。Rust 也能创建匿名函数。Rust 的匿名函数叫做闭包（closure）。单说闭包可能没什么意思，但当你把它和以闭包为参数的函数结合起来用，他就变得非常强大。

创建一个 闭包：

	let add_one = |&: x| { 1 + x };

	println!("The sum of 5 plus 1 is {}.", add_one(5));

我们使用 `|...|{...} ` 句法创建一个闭包，然后绑定一个名称。注意，我们使用绑定的名称加小括号来调用这个函数，和调用普通函数一样。

我们比较一下句法。很接近：

	let add_one = |&: x: i32| -> i32 { 1 + x };
	fn  add_one      (x: i32) -> i32 { 1 + x }
	
你可能已经注意到，闭包可以推断出参数和返回值，因此没必要声明一个。这点和实名函数不一样。

匿名函数和实名函数有个巨大区别，正如名字所揭示的：闭包包住了他的上下文。这意味着：

	fn main() {
    	let x: i32 = 5;

    	let printer = |&:| { println!("x is: {}", x); };

    	printer(); // prints "x is: 5"
	}
	
`|&:|` 句法意味着这是个不包含参数的闭包.闭包能通过 borrow 方式获取作用域里的变量。

	fn main() {
    	let mut x: i32 = 5;

    	let printer = |&:| { println!("x is: {}", x); };

    	x = 6; // error: x 是 borrow 过来的没法赋值
	}
	
#转移闭包

Rust 还有另外一种闭包，叫做转移闭包。转移闭包用 move 关键字标示。转移闭包和普通闭包不同之处在于，转移闭包总是拿走所有用到变量的 ownership。相比之下普通闭包只是在包围栈帧内创建了一个引用。移动闭包最大的用处是和 Rust 的并发结合。这里暂且不表，后面在线程章节里面再谈论。

#闭包作为参数

闭包最为参数传递给一谈函数很有用，举个例子：

	fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
	    f(x) + f(x)
	}

	fn main() {
	    let square = |&: x: i32| { x * x };

	    twice(5, square); // evaluates to 50
	}

	
